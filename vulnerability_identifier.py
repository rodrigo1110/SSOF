#Code for identifying vulnerabilites in program slice by comparing correspondent flow graph to vulnerabilities recieved as 2nd argument
import itertools
from Pattern import Pattern
from OutputVulnerability import OutputVulnerability
from FlowGraph import FlowGraph
from Tainted import Tainted


vulnerabilities = []

def flow_pairs(source_indexes, sink_indexes):
    """ A function that returns the valid flow pairs """
    return [(x, y) for x in source_indexes for y in sink_indexes if x < y]

    
def valid_sanitizers(sanitizers_in_path, path, pairs):
    """ A function that returns all the valid sanitizers between source-sink pairs """
    result = []
    for sanitizer in sanitizers_in_path:
        index = path.index(sanitizer)
        for (source, sink) in pairs:
            if source < index < sink and sanitizer not in result:
                result.append(sanitizer)

    return result


def get_contained(list1, list2):
    finalList = []
    for el in list1:
        if el in list2:
            finalList.append(el)
    return finalList
    


def getOriginalSource(listTainted, tainted):
    for taint in listTainted:
        if(tainted.origin in taint.taintedList):
            return getOriginalSource(listTainted, taint)
    return tainted.origin



def getIndex(list1,value):
    for i in range(0,len(list1)): #might have problem without len(list) - 1? Nvm range doesnt include last value
        if(list1[i] == value):
            return i 
    


def getBiggest(list1):
    biggest = 0
    for i in range(0,len(list1)) : #might have problem without len(list) - 1? Nvm range doesnt include last value
        if(list1[i] > biggest):
            biggest = list1[i]
    return biggest
        

#No detection of implicit flows, only explicit ones
def identifyVulnerabilities(flowGraph, patterns):
    
    paths = flowGraph.paths()
    
    for pattern in patterns: #Just for testing     
        pattern.toString()
    
    for path in paths:
        print(path)
    print("\n")
    
    identifiedVulnerabilities = []
    toReturnVulnerabilities = []
    taintedMatrixFinal = [[]]
    
    """
    for pattern in patterns: #Adds uinstantiated variables as entry points to all vulnerabilities. Works well but has negative effect on output.  
                                                Instead of adding unintiated varibale to patterN.sources add it to a list and check it in last for.
        sourceCandidates = []
        for path in paths:
            for el in path:
                if((el != path[len(path)-1]) and (el != "root") and (el not in pattern.sources) and (el not in sourceCandidates)):
                    if(not el.isnumeric() and len(el) != 0 and el not in pattern.sanitizers and el in pattern.sinks):
                        sourceCandidates.append(el)
                #if((el ==  path[len(path)-1]) and (el in sourceCandidates)):
                 #   sourceCandidates.remove(el) #already instantiated.
        print("source candidates:", sourceCandidates[:])
        for path in paths:
            if(path[-1] in sourceCandidates):
                sourceCandidates.remove(path[-1]) #already instantiated.

        if(len(sourceCandidates) != 0):
            for el2 in sourceCandidates:
                pattern.sources.append(el2)

    
    
    print("New patterns sources")
    for pattern in patterns:     
        pattern.toString()
    
    print("----------\n")
    """
    
    
    
    flag = False
    i=0
    i_path = 0
    for pattern in patterns: #PROBLEM only works if a tainted b and b tainted sink d. if b tainted c and c tainted sink d doesnt work because c isnt stored in tainted matrix since b isnt a source
        for path in paths:
            toAdd = []
            sourcesPath = get_contained(path, pattern.sources)
            sanitizersPath = get_contained(path, pattern.sanitizers)

            
            for el3 in taintedMatrixFinal[i]: #added tainted variable as origin of new taint to attempt to solve problem above. 
                for el4 in get_contained(path, el3.taintedList):
                    if((el4 not in pattern.sources) and (el4 not in sourcesPath) and (el4 not in pattern.sanitizers)): #and (el4 not in pattern.sinks)):  #sinks added because contaminated sink can also contaminate                                                                          
                       sourcesPath.append(el4)                                                                      
                                                                                                                    
            #print(sourcesPath)
            sinksPath = get_contained(path,pattern.sinks) #Not used for now in this if

            if(len(sourcesPath) != 0): 
                
                print("sources path list after if:", sourcesPath)
                
                for el in path: #makes sure just the variables in path that arent root nor origins are added to taint list
                    if((el != 'root') and (el not in pattern.sources) and (el not in pattern.sanitizers)):  #«« and (el not in pattern.sinks))): ##add back soon (maybe)
                        toAdd.append(el)
                print("ToAdd:", toAdd[:])            
                
                

                
                for source in sourcesPath: #adds tainted variables to taint list
                    #print(i)
                    toAdd2 = []
                    for el5 in toAdd:
                        if(getIndex(path,el5) > getIndex(path,source)):
                            toAdd2.append(el5)
                            ##toAdd.remove(el5)
                            print("ToAdd after remove:",toAdd2)
                    
                    certifiedSanitizers = [[]]
                    for el6 in sanitizersPath:
                        if(getIndex(path,el6) > getIndex(path,source)):
                            certifiedSanitizers[0].append(el6)
                            print("Sanitizers after validation:",certifiedSanitizers)
                   

                    flag = False
                    for tainted in taintedMatrixFinal[i]:
                        if(source == tainted.origin):                                      #if tainted object with origin == source value already exists 
                            print("source already exists for tainted variable")
                            for el2 in toAdd2:
                                if(el2 not in tainted.taintedList and el2 != tainted.origin): #no duplicates or adding origin to tainted list
                                    #print("ToAdd el after verification:" , el2)
                                    tainted.taintedList.append(el2)
                                    index = getIndex(tainted.taintedList,el2)
                                    tainted.sanitizedList[index].append(certifiedSanitizers[0])
                                else:
                                    index2 = getIndex(tainted.taintedList,el2)
                                    if(tainted.sanitizedList[index2] != []):
                                        if(certifiedSanitizers[0] == []):
                                            tainted.sanitizedList[index2] = certifiedSanitizers[0]
                                        else:
                                            for el7 in certifiedSanitizers[0]:
                                                if(el7 not in tainted.sanitizedList[index2]):
                                                    tainted.sanitizedList[index2].append(el7)

                            flag = True
                            break

                    if(flag == False): #If tainted object with origin == source value doesnt exist yet
                        toAdd3 = []
                        for el2 in toAdd2:
                            if(el2 != source): #so he doesnt add himself as origin and beloging to tainted list of that origin
                                toAdd3.append(el2)
                                #print("ToAdd2 after copying:" , toAdd2[:])
                        if(len(toAdd3)!=0):
                            taintedMatrixFinal[i].append(Tainted(source,toAdd3,[]))  #toAdd2 before
                            for v in range(0,len(toAdd3)):
                                taintedMatrixFinal[i][-1].sanitizedList.append(certifiedSanitizers[0])
                            print("sanitized list:", taintedMatrixFinal[i][-1].sanitizedList)
                        #print(i)
            i_path += 1           
            #for printt in taintedMatrixFinal[i]:
             #   print("taintedMatrix so far:")
              #  printt.toString()
            
        i += 1
        taintedMatrixFinal.append([])              
        flag = False
    

    i=0
    print("-----------------\n")
    print("-----------------\n")
    for lst in taintedMatrixFinal:
        print("\nIteration", i)
        for tainted in lst:
            tainted.toString()
        i  += 1
    
    print("-----------------\n")
    for path in paths:
        print(path)
    print("\n")
    #print(getOriginalSource(taintedMatrixFinal[0],taintedMatrixFinal[0][1])) #test: works
    




##### ADD for cycle to check for all patterns, for every path if there is a sanitizer. if there is remove from tainted list variables in that path
###or add a flag saying they've been sanitized and by whom


    i = 0
    n = 1
    for pattern in patterns:                                                        
        if(i!=0):
            print(pattern.vulnerability, "\n-------------------", i)
        for path in paths:
            print("Path:", path)
            print("Pattern Sources:", pattern.sources, "Pattern Sinks:" ,pattern.sinks)
            sources_in_path = get_contained(path, pattern.sources)
            print("Sources in path:", sources_in_path)
            sinks_in_path = get_contained(path, pattern.sinks)
            print("Sinks in path:", sinks_in_path)
            sanitizers_in_path = get_contained(path, pattern.sanitizers)
            print("Sanitizers in path:", sanitizers_in_path)
            
            certifiedSanitizers = []
            certifiedSinks = [[]]
            count = 0
            for sourcee in sources_in_path: #Verify if source is tainting sink or merely being attributed a sink value
                for sinkk in sinks_in_path:   
                    if(getIndex(path,sinkk) > getIndex(path,sourcee)):
                        certifiedSinks[count].append(sinkk)
                if(count != (len(sources_in_path) - 1)):
                    certifiedSinks.append("[]")
                count += 1

            
            
            
            
            if(len(sinks_in_path) != 0): #ERRO quando lista de sinks_in_path = [d,e]. se d nao for afetado por x mas e for entao vai adicionar x aos source in path 
                    for el in path:                                                 # e depois para alem de adicionar vuln x->e (como devido) adiciona tb x->d
                        for tainted in taintedMatrixFinal[i]:
                            toAddCertified = []
                            if((el in tainted.taintedList) and (tainted.origin not in sources_in_path)):  #found tainted object in path. obtain who originally tainted that object
                                index = getIndex(tainted.taintedList,el)
                                originalSource = getOriginalSource(taintedMatrixFinal[i],tainted)           #add original and sanitizers in path to it to certefied sanitizers
                                if(originalSource not in sources_in_path): 
                                    
                                    for sink in sinks_in_path:                         
                                        if(getIndex(path,sink) >= getIndex(path,el)): #verifies order and fixes error above(= after > fixes it)
                                            toAddCertified.append(sink)

                                    if(len(toAddCertified) != 0):
                                        if(len(certifiedSinks[0]) == 0):
                                            certifiedSinks.pop(0)
                                        certifiedSinks.append(toAddCertified)

                                    #for sanitizer in tainted.sanitizedList[index]:
                                     #   if(sanitizer not in certifiedSanitizers):
                                      #      certifiedSanitizers.append(sanitizer)

                                    sources_in_path.append(originalSource)                                  
                                    print("New path sources:", sources_in_path)       

                   # for sanitizer in sanitizers_in_path:  #add and correct later(error)
                    #    for source in sources_in_path:
                     #       for sink in sinks_in_path:
                      #          if(getIndex(path,sink) > getIndex(path,sanitizer) > getIndex(path,source)):  #source could have been empty, changed to here
                       #             certifiedSanitizers.append(sanitizer)                                      
                                    

            
            for certifiedSink in certifiedSinks:
                print("Certified Sinks:", certifiedSink)
            #print("Certified Sanitizers:", certifiedSanitizers)
            print("----------------------")
            
            
            for source in sources_in_path:  #Doesnt check sanitization yet.
                for sinkList in certifiedSinks:
                    for sink in sinkList:
                        flagAppend = True
                        
                        
                        vuln = OutputVulnerability(pattern.vulnerability, source, sink, "yes", [])
                        for vulnerability in identifiedVulnerabilities: # eliminates duplicates 
                            if(vuln == vulnerability):          
                                flagAppend = False  
                                #print("Duplicate found! Not adding it to vulnerability list")                          
                        if(flagAppend):
                            print("+++++++++++++++++++++++")
                            identifiedVulnerabilities.append(vuln)
                            vulnToReturn = OutputVulnerability(vuln,n)
                            n += 1
                            vulnToReturn.toString()
                            print("-----------------------")
                            toReturnVulnerabilities.append(vulnToReturn)

        i += 1    
        n = 1
        
        

    return toReturnVulnerabilities
